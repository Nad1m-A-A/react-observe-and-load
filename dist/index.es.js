import r,{useState as e,useEffect as t,useRef as n}from"react";function o(r,n){const[o,l]=e(null),[a,i]=e(null),[s,c]=e(!1);return t((()=>{if(!n||!Array.isArray(r)||0===r.length)return l(null),void i(null);let e=!0;return(async()=>{c(!0),i(null);try{const t=await Promise.all(r.map((async r=>{try{const e=await import(r);return e.default||e}catch(e){throw new Error(`Failed to load: ${r}`)}})));if(!e)return;const n=t.reduce(((r,e)=>{const t=function(r){const e=Object.entries(r).filter((([r,e])=>Array.isArray(e))).reduce(((r,[e,t])=>(r[e]=t,r)),{});return Object.keys(e).length>0?e:r}(e);return{...r,...t}}),{});l(n)}catch(r){e&&(i(r.message||"Failed to load data"),l(null))}finally{e&&c(!1)}})(),()=>{e=!1}}),[r,n]),{data:o,error:a,loading:s}}function l({rootMargin:r="0px",threshold:o=0,triggerOnce:l=!0,root:a=null}={}){const[i,s]=e(!1),c=n(null);return t((()=>{let e=!0;const t=new IntersectionObserver((([r])=>{e&&(r.isIntersecting?(s(!0),l&&t.disconnect()):l||s(!1))}),{root:a,rootMargin:r,threshold:o}),n=c.current;return n&&t.observe(n),()=>{e=!1,n&&t.unobserve(n),t.disconnect()}}),[r,o,l,a]),{ref:c,inView:i}}function a(e,{animate:t=!1,afterWrapperIsVisibleClass:n="visible_wrapper",initialWrapperClass:a=(t?"invisible_wrapper":""),rootMargin:i="0px",threshold:s=0,root:c=null,triggerOnce:u=!0,lazyLoad:d=!1,files:g=[]}={}){return function(f){const{ref:p,inView:h}=l({rootMargin:i,threshold:s,root:c,triggerOnce:u}),{data:y,error:m,loading:w}=d?o(g,h):{data:null,error:null,loading:!1},b=t&&h?f.special_animation||n:a,v=d?{...f,content:y,error:m,loading:w}:f;return r.createElement("div",{ref:p,className:b,style:f.style},r.createElement(e,v))}}export{l as useElementObserver,o as useLazyLoadData,a as withViewObserver};
